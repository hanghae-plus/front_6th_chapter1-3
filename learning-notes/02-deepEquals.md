# deepEquals 함수 구현 및 질문 정리

## 주요 논의 및 개선 과정

- 기본 타입/값은 === 비교로 빠르게 처리
- 객체/배열 비교를 한 번에 처리하는 구조로 리팩토링
- 배열 여부는 Array.isArray로 한 번에 체크, 둘 중 하나만 배열이면 false
- 객체의 키 개수 비교, 키 존재 여부, 각 값에 대해 재귀적으로 deepEquals 호출
- for문 조건을 긍정문으로 분리하여 가독성 향상

- 양쪽 키 모두 비교하는 이유:
  - 한쪽 객체에만 있는 키가 있을 때도 정확하게 false를 반환할 수 있음
  - 엣지 케이스(예: `{ a: 1 }` vs `{ a: 1, b: 2 }`)까지 완벽하게 처리
  - Lodash 등 실제 라이브러리도 이 방식을 사용
  - 논리적으로 완전한 깊은 비교를 보장함

  "한쪽에만 있는 키"까지 모두 체크해야
  실제로 구조가 완전히 같은지, 아니면 다른지
  엣지 케이스까지 완벽하게 비교할 수 있습니다.

## 주요 질문 및 답변

- 왜 === 비교가 필요한가? → 값이 완전히 같을 때 빠르게 true 반환
- 배열인지 확인은 어디서? → Array.isArray로 한 번에 처리
- 재귀적으로 각 속성에 대해 deepEquals 호출이 실제로 구현됨
- 긍정문 vs 부정문 → 긍정문이 가독성에 더 좋음
- 타입은 any 대신 Record<string, unknown>으로 변경해 lint 경고 해결
