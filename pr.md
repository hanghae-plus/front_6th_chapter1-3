## 과제 체크포인트

### 배포 링크

<!--
배포 링크를 적어주세요
예시: https://<username>.github.io/front-6th-chapter1-3/

배포가 완료되지 않으면 과제를 통과할 수 없습니다.
배포 후에 정상 작동하는지 확인해주세요.
-->

### 기본과제

#### equalities

- [x] shallowEquals 구현 완료
- [x] deepEquals 구현 완료

#### hooks

- [x] useRef 구현 완료
- [x] useMemo 구현 완료
- [x] useCallback 구현 완료
- [x] useDeepMemo 구현 완료
- [x] useShallowState 구현 완료
- [x] useAutoCallback 구현 완료

#### High Order Components

- [x] memo 구현 완료
- [x] deepMemo 구현 완료

### 심화 과제

#### hooks

- [x] createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선
- [x] useShallowSelector 구현
- [x] useStore 구현
- [x] useRouter 구현
- [x] useStorage 구현

### context

- [x] ToastContext, ModalContext 개선

## 과제 셀프회고

- shallow compare 회고
  https://github.com/hanghae-plus/front_6th_chapter1-3/issues/47

<!-- 과제에 대한 회고를 작성해주세요 -->

### 기술적 성장

## useSyncExternalStore

이번에 외부 스토어를 직접 구현해보면서 useSyncExternalStore를 사용해보았다.
useSyncExternalStore 자체는 아주 간단하고 가벼운 내용이지만 왜 등장했는지부터, 어떤 문제를 해결하고자 했는지를 어떤 부작용이 있는지 깊게 학습해볼 수 있었다.

### 왜 등장했는지

react 18의 동시성 기능(Suspense, startTransition, streaming SSR)이 도입되면서, 렌더링 중에 일시 중지 하고 나중에 이어서 렌더링하는 기능이 생겨났다.

하지만 이 때 외부 상태관리와 함께 사용하면 tearing라고 말하는 렌더링 상태 불일치가 발생한다.

```
// 컴포넌트 A와 B가 같은 외부 store를 읽음
// React가 A만 먼저 렌더하다가 중간에 멈춤(yield)
// 그 사이 외부 store 값이 변경됨
// B는 최신값으로 렌더되지만 A는 이전값 → 불일치 발생
```

이 문제를 해결하기 위해 useSyncExternalStore 가 도입되었다.

### 문제

tearing문제는 해결되었지만 useSyncExternalStore는 동시성 렌더링과 올바르게 동작하지 않는다.

zustand는 useSyncExternalStore기반으로 구성되어있다.

zustand를 예시로 들어서 코드를 살펴보았다.
https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-psqczj?file=%2Fsrc%2FApp.js%3A41%2C38

해당 코드를 보면 suspense 대기까지 isPending으로 동작했어야했지만 isPending이 노출되지 않는다.

useSyncExternalStore로부터 업데이트된 상태변경이 즉각반응하고 startTransition을 통해 업데이트 되었는지 알 수 없기 때문이다.

### 대안? 트레이드 오프?

반면에 jotai는 store를 useEffect로 구독하는 형태로 구성되어있다.
useSyncExternalStore를 사용하지 않고 React 상태에 의존성을 두었다.

zustand때와 거의 동일한 흐름의 코드이지만 isPending이 아주 잘 동작한다.
https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-t2pqlr

jotai는 react 상태 기반으로 state가 관리되기 때문에 startTransition을 통해서 의도된 렌더링 흐름이 흘러간다.

그러나 당연히 그러면 그냥 외부스토어를 구독한 상태가 되니 처음에 발생했던 tearing 문제가 다시 발생한다.
https://codesandbox.io/p/sandbox/react-tearing-jotai-wqwwqt?file=%2Fsrc%2FCounter.js%3A10%2C1

https://blog.axlight.com/posts/why-use-sync-external-store-is-not-used-in-jotai/
jotai 개발자 블로그글에 자세히 설명이 되어있다.

결국 라이브러리마다 해결하고자 하는 방향이 있는거고 zustand와 jotai 모두 각각의 의도가 있는 것이다.

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 자랑하고 싶은 코드

PR을 자랑하고 싶습니다..

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 개선이 필요하다고 생각하는 코드

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

## 학습 갈무리

### 리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.

<!-- 예시
- 리액트의 렌더링 과정
- 리액트의 렌더링 최적화 방법
- 리액트의 렌더링과 관련된 개념들 (예: Virtual DOM, Reconciliation 등)
- 리액트의 렌더링과 관련된 라이프사이클 메서드
- 리액트의 렌더링과 관련된 Hooks (예: useMemo, useCallback 등)
-->

### 메모이제이션에 대한 나의 생각을 적어주세요.

### 메모이제이션?

리액트에서는 state, props, context가 변경되면 해당 컴포넌트에서 리렌더링이 발생하고 컴포넌트 안에 있는 모든 값들은 다시 재계산 된다.

이 때 실제로 재계산이 필요한 경우에만 재계산하도록 하는 의도로 메모이제이션을 한다.

## 사용하지 않았을 때 발생할 수 있는 문제

만약에 props로 넘기는 변수가 object라면 리렌더링이 될 때 마다 재할당이 되고 당연히 메모리주소가 바뀌며 props가 변경되었다고 인식한다.

만약 성능이 좋지 않은 list 아이템 컴포넌트에 props를 넘겼다면, 렌더링이 발생할 때 마다 list 아이템 컴포넌트를 재계산하는데 아주 큰 성능이슈가 발생하게 될 것이다.

이 때 React.memo와 React.useMemo를 사용해서 불필요한 렌더링을 막을 수 있을 것이다.

## 메모이제이션에 대한 장점, 단점, 나의 생각

리액트에서 메모이제이션에 대한 논쟁은 핫하다.

회사에서만해도 우리는 의견이 갈리고 있다.
리드 개발자분의 의견은 어떤곳에는 쓰고 안쓰고 생각하는 고민 비용도 비싸고, 굳이 그럴 이유도 없다는 의견이다.
애초에 비싼 계산을 하는 곳도 없고 문제도 없는 코드들이라는게 뻔히 보이는데 왜 넣어야되는지가 이해안된다.

물론 어떤 맥락인지는 이해가 되지만 심적으로 불편하다..

- 극단적으로 예시를 든 코드

```jsx
//메모를 해도 안해도 렌더링이 발생하는 곳에서 왜 항상 얕은 비교 코드를 불필요하게 실행시키는가!
const [state, setState] = React.useState(0);

const memoizedValue = useMemo(() => {
  return state * 2; // 예시로 상태의 두 배를 계산
}, [state]);
return (
  <div>
    {memoizedValue}
    <button onClick={() => setState(state + 1)}>Increment</button>
  </div>
);
```

결론은 생각하는 비용자체보다 그냥 다 쓰는게 더 저렴할 수 있다고는 하지만, 내가 생각하는 이상적인 메모이제이션은 느린 리렌더링이 발생하는 경우의 문제를 해결할 때 사용하면 된다고 생각한다.

### 컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.

## 전역상태관리 왜 필요할까

최근에는 전역상태관리의 필요성 자체가 많이 줄어들고 있다.

tanstack-query 같은 서버 상태 관리 라이브러리가 없을 때는 서버 데이터 요청을 과도하게 하지 않기 위해서 전역적으로 데이터 저장소를 두어 관리하기도 하였다.
최근에는 서버 상태 관리 라이브러리가 이런 부분을 채워주고 있고, 전역상태라는게 필요한 경우가 없다라고 말할 정도로 필요성이 줄어들었다.

나의 생각도 비슷하다.
전역상태관리는 특수한 경우를 제외하고 앱 기능을 만들 때는 거의 불필요하다. ex) global snackbar?
게다가 웹에서는 searchParams라는 UI 정보를 보여주는 아주 좋은 요소도 있다.(심지어 지라에서는 모달을 띄워주는 요소로도 사용하고 있다)

하지만 전역상태관리는 필요없다해도 scope 단위의 상태관리는 매우 유용하다.
개발자의 의도를 담고 클린하게 코드를 관리하기 아주 좋은 방법이라 생각한다.

정리해보자면, 전역상태라이브러리라고 칭하고 있긴 하지만, 필요성이 줄었고 지금은 스코프 단위의 상태관리로써 접근하는게 좋다고 생각한다.
(앱 전역에서 사용해야된다면 앱 전체의 스코프 상태관리라고 접근한다)

### Context Hook

[Context Hook](https://ko.react.dev/reference/react/useContext)은 Context를 Provider 내부에 있는 자식 컴포넌트들에게 제공해주는 Hook이다. (Provider 내부가 스코프가 된다.)

동작 방식은 Provider에 제공된 context 값을 공유하게 되고 Object.is를 통해 변경되었는지 감지하여 리렌더링한다.
이 때 useContext를 통해 사용하는 자식 컴포넌트들은 모두 함께 리렌더링이 되는 흐름이다.

외부 라이브러리를 사용할필요 없이 React만 사용한다면 바로 사용할 수 있다.

그러나 단순히 그냥 상태관리로써 사용하기에는 렌더링 최적화하는 일련의 과정이 간편하지 않다.

그런데 여기서 하나 더 짚고가야될 점이 있다.
렌더링이 정말 문제인가도 생각해보자.

### 렌더링

렌더링은 문제일 수도 있는거지, 무조건 문제라고 말하기는 어렵다.

렌더링 과정을 간략하게 보면 아래와 비슷하다.

```
render → reconciliation → commit
      ↖                   ↙
           state change

```

기본적으로 렌더링이 발생해도 reconciliation과정에서 VDom과 Dom과 비교했을 때 변화가 없다면, 커밋이 일어나지 않는다.
Context Hook으로 상태관리할 때를 예로 들자면, 불필요하게 리렌더링이 발생하는 컴포넌트라고해도 실제로는 어차피 commit이 일어나지 않는다.
커밋이 없는 경우에는 dom이 바뀌지 않고, 사용자에게 영향을 주지 않을 것이다.

물론 렌더링 과정만으로 영향을 주는 경우도 있다.
렌더링중에 느린 렌더링이 발생하면 연산과정이 많아지면서 의도치 않게 버벅이는 현상을 마주하게 된다.

전달하고자 하는 말은 느린 렌더링만 발생하지 않는다면, 즉 앱을 내가 효율적으로 잘 관리하고만 있다면,
useContext는 간편하고 좋은 상태관리 수단이 될 수 있다는 말을 하고 싶다.

> - 내가 생각하는 효율적인 관리
>   useMemo, useCallback, memo 등의 memoization hook을 사용해서 느린 렌더링을 관리해서 효율적으로 관리하는 것을 얘기함

### context hook에 대한 나의 생각

위에서 말한거처럼 효율적으로 앱을 관리하고 있다면 context hook은 리액트 내부코드이기때문에 tearing 현상을 걱정할 필요도 없고, 쉽고 예측가능한 코드를 작성할 수 있다. 상태관리 수단으로도 괜찮은 방법일 수 있다.

하지만 이런 과정을 고민하고 적용하는 것 자체가 상당히 귀찮다고 생각한다.(애초에 상태관리하도록 제공해주는 메서드가 없으니..)
그리고 리액트 개발자는 리렌더링을 극도로 거부감 느끼도록 가스라이팅을 당했기 때문에 나도 거부감이 강하기도 하다.

그래서 context hook은 기본적으로 상태를 주입하는 용도로 사용할 때 좋다고 생각한다.(애초에 그러라고 만들어진 API)
데이터를 주입하는 용도로만 사용할 때 불필요한 렌더링 발생 걱정도 없고, 작성자의 의도를 명확히 파악할 수 있기도 하다.

<!-- 예시
- 컨텍스트와 상태관리가 필요한 이유는 무엇일까?
- 컨텍스트와 상태관리를 사용하지 않으면 어떤 문제가 발생할까?
- 컨텍스트와 상태관리를 사용했을 때의 장점과 단점은 무엇일까?
- 컨텍스트와 상태관리를 사용하지 않고도 해결할 수 있는 방법은 무엇일까?
- 컨텍스트와 상태관리를 사용할 때 주의해야 할 점은 무엇일까?
-->

## 리뷰 받고 싶은 내용

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 질문의 예시)
- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 질문의 예시)
- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?
- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.
- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?
- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?

과제에서 디테일한 피드백을 받기 위해선 여러분의 생각을 디테일하게 표현해주셔야 한답니다.

가령, "전반적으로 이 라우터 구조가 규모가 커졌을 때 유지보수나 기능 확장에 유리한지, 아니면 리팩토링이 필요할지 조언을 받고 싶습니다" 라는 질문이 있을 때, 답변드리기가 어려워요.
이럴 때는 "기능 확장" 상황을 먼저 가정해봐야합니다. 테스트의 엣지케이스를 작성하는 것 처럼요! 그리고 그 상황에 대해 내가 작성한 코드가 이러저러한 이유 때문에 대응가능할 것 같은데 혹시 더 고려해야할 부분이 있을지를 물어보는거죠.

이건 코치에게 이야기할 때 뿐만 아니라 팀원에게 이야기할 때에도 동일해요. 여러분의 컨텍스트를 명확하게 전달하지 않으면 여러분과 이야기할 때 시간이 무척 오래 걸린답니다.

특히 멘토링 처럼 동기적으로 이루어지는 커뮤니케이션에서는 위와 같은 질문을 던져도, 상호 피드백으로 질문을 함께 만들어갈 수 있지만, 과제 피드백 처럼 비동기 방식 + 1회용 질문일 때에는 좋은 답변을 드리기가 어려운점 인지 부탁드립니다 ㅠㅠ
-->
