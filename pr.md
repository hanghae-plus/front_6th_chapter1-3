## 과제 체크포인트

### 배포 링크

<!--
배포 링크를 적어주세요
예시: https://<username>.github.io/front-6th-chapter1-3/

배포가 완료되지 않으면 과제를 통과할 수 없습니다.
배포 후에 정상 작동하는지 확인해주세요.
-->

### 기본과제

#### equalities

- [x] shallowEquals 구현 완료
- [x] deepEquals 구현 완료

#### hooks

- [x] useRef 구현 완료
- [x] useMemo 구현 완료
- [x] useCallback 구현 완료
- [x] useDeepMemo 구현 완료
- [x] useShallowState 구현 완료
- [x] useAutoCallback 구현 완료

#### High Order Components

- [x] memo 구현 완료
- [x] deepMemo 구현 완료

### 심화 과제

#### hooks

- [x] createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선
- [x] useShallowSelector 구현
- [x] useStore 구현
- [x] useRouter 구현
- [x] useStorage 구현

### context

- [x] ToastContext, ModalContext 개선

## 과제 셀프회고

- shallow compare 회고
  https://github.com/hanghae-plus/front_6th_chapter1-3/issues/47

<!-- 과제에 대한 회고를 작성해주세요 -->

### 기술적 성장

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 자랑하고 싶은 코드

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 개선이 필요하다고 생각하는 코드

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

## 학습 갈무리

### 리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.

<!-- 예시
- 리액트의 렌더링 과정
- 리액트의 렌더링 최적화 방법
- 리액트의 렌더링과 관련된 개념들 (예: Virtual DOM, Reconciliation 등)
- 리액트의 렌더링과 관련된 라이프사이클 메서드
- 리액트의 렌더링과 관련된 Hooks (예: useMemo, useCallback 등)
-->

### 메모이제이션에 대한 나의 생각을 적어주세요.

<!-- 예시
- 메모이제이션이 언제 필요할까?
- 메모이제이션을 사용하지 않으면 어떤 문제가 발생할까?
- 메모이제이션을 사용했을 때의 장점과 단점은 무엇일까?
- 메모이제이션을 사용하지 않고도 해결할 수 있는 방법은 무엇일까?
-->

### 컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.

## 전역상태관리 왜 필요할까

최근에는 전역상태관리의 필요성 자체가 많이 줄어들고 있다.

tanstack-query 같은 서버 상태 관리 라이브러리가 없을 때는 서버 데이터 요청을 과도하게 하지 않기 위해서 전역적으로 데이터 저장소를 두어 관리하기도 하였다.
최근에는 서버 상태 관리 라이브러리가 이런 부분을 채워주고 있고, 전역상태라는게 필요한 경우가 없다라고 말할 정도로 필요성이 줄어들었다.

나의 생각도 비슷하다.
전역상태관리는 특수한 경우를 제외하고 앱 기능을 만들 때는 거의 불필요하다. ex) global snackbar?
게다가 웹에서는 searchParams라는 UI 정보를 보여주는 아주 좋은 요소도 있다.(심지어 지라에서는 모달을 띄워주는 요소로도 사용하고 있다)

하지만 전역상태관리는 필요없다해도 scope 단위의 상태관리는 매우 유용하다.
개발자의 의도를 담고 클린하게 코드를 관리하기 아주 좋은 방법이라 생각한다.

정리해보자면, 전역상태라이브러리라고 칭하고 있긴 하지만, 필요성이 줄었고 지금은 스코프 단위의 상태관리로써 접근하는게 좋다고 생각한다.
(앱 전역에서 사용해야된다면 앱 전체의 스코프 상태관리라고 접근한다)

### Context Hook

[Context Hook](https://ko.react.dev/reference/react/useContext)은 Context를 Provider 내부에 있는 자식 컴포넌트들에게 제공해주는 Hook이다. (Provider 내부가 스코프가 된다.)

동작 방식은 Provider에 제공된 context 값을 공유하게 되고 Object.is를 통해 변경되었는지 감지하여 리렌더링한다.
이 때 useContext를 통해 사용하는 자식 컴포넌트들은 모두 함께 리렌더링이 되는 흐름이다.

외부 라이브러리를 사용할필요 없이 React만 사용한다면 바로 사용할 수 있다.

그러나 단순히 그냥 상태관리로써 사용하기에는 렌더링 최적화하는 일련의 과정이 간편하지 않다.

그런데 여기서 하나 더 짚고가야될 점이 있다.
렌더링이 정말 문제인가도 생각해보자.

### 렌더링

렌더링은 문제일 수도 있는거지, 무조건 문제라고 말하기는 어렵다.

렌더링 과정을 간략하게 보면 아래와 비슷하다.

```
render → reconciliation → commit
      ↖                   ↙
           state change

```

기본적으로 렌더링이 발생해도 reconciliation과정에서 VDom과 Dom과 비교했을 때 변화가 없다면, 커밋이 일어나지 않는다.
Context Hook으로 상태관리할 때를 예로 들자면, 불필요하게 리렌더링이 발생하는 컴포넌트라고해도 실제로는 어차피 commit이 일어나지 않는다.
커밋이 없는 경우에는 dom이 바뀌지 않고, 사용자에게 영향을 주지 않을 것이다.

물론 렌더링 과정만으로 영향을 주는 경우도 있다.
렌더링중에 느린 렌더링이 발생하면 연산과정이 많아지면서 의도치 않게 버벅이는 현상을 마주하게 된다.

전달하고자 하는 말은 느린 렌더링만 발생하지 않는다면, 즉 앱을 내가 효율적으로 잘 관리하고만 있다면,
useContext는 간편하고 좋은 상태관리 수단이 될 수 있다는 말을 하고 싶다.

> - 내가 생각하는 효율적인 관리
>   useMemo, useCallback, memo 등의 memoization hook을 사용해서 느린 렌더링을 관리해서 효율적으로 관리하는 것을 얘기함

### context hook에 대한 나의 생각

위에서 말한거처럼 효율적으로 앱을 관리하고 있다면 context hook은 리액트 내부코드이기때문에 tearing 현상을 걱정할 필요도 없고, 쉽고 예측가능한 코드를 작성할 수 있다. 상태관리 수단으로도 괜찮은 방법일 수 있다.

하지만 이런 과정을 고민하고 적용하는 것 자체가 상당히 귀찮다고 생각한다.(애초에 상태관리하도록 제공해주는 메서드가 없으니..)
그리고 리액트 개발자는 리렌더링을 극도로 거부감 느끼도록 가스라이팅을 당했기 때문에 나도 거부감이 강하기도 하다.

그래서 context hook은 기본적으로 상태를 주입하는 용도로 사용할 때 좋다고 생각한다.(애초에 그러라고 만들어진 API)
데이터를 주입하는 용도로만 사용할 때 불필요한 렌더링 발생 걱정도 없고, 작성자의 의도를 명확히 파악할 수 있기도 하다.

<!-- 예시
- 컨텍스트와 상태관리가 필요한 이유는 무엇일까?
- 컨텍스트와 상태관리를 사용하지 않으면 어떤 문제가 발생할까?
- 컨텍스트와 상태관리를 사용했을 때의 장점과 단점은 무엇일까?
- 컨텍스트와 상태관리를 사용하지 않고도 해결할 수 있는 방법은 무엇일까?
- 컨텍스트와 상태관리를 사용할 때 주의해야 할 점은 무엇일까?
-->

## 리뷰 받고 싶은 내용

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 질문의 예시)
- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 질문의 예시)
- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?
- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.
- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?
- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?

과제에서 디테일한 피드백을 받기 위해선 여러분의 생각을 디테일하게 표현해주셔야 한답니다.

가령, "전반적으로 이 라우터 구조가 규모가 커졌을 때 유지보수나 기능 확장에 유리한지, 아니면 리팩토링이 필요할지 조언을 받고 싶습니다" 라는 질문이 있을 때, 답변드리기가 어려워요.
이럴 때는 "기능 확장" 상황을 먼저 가정해봐야합니다. 테스트의 엣지케이스를 작성하는 것 처럼요! 그리고 그 상황에 대해 내가 작성한 코드가 이러저러한 이유 때문에 대응가능할 것 같은데 혹시 더 고려해야할 부분이 있을지를 물어보는거죠.

이건 코치에게 이야기할 때 뿐만 아니라 팀원에게 이야기할 때에도 동일해요. 여러분의 컨텍스트를 명확하게 전달하지 않으면 여러분과 이야기할 때 시간이 무척 오래 걸린답니다.

특히 멘토링 처럼 동기적으로 이루어지는 커뮤니케이션에서는 위와 같은 질문을 던져도, 상호 피드백으로 질문을 함께 만들어갈 수 있지만, 과제 피드백 처럼 비동기 방식 + 1회용 질문일 때에는 좋은 답변을 드리기가 어려운점 인지 부탁드립니다 ㅠㅠ
-->
